---
layout: post
title:  "Epoll实验总结"
date:   2016-09-03 10:09:35
categories: [blog]
tags: [Linux, C, ]
description: ""
---

# Epoll实验总结


## 一、超时实验

### 1. 安装后的第一步
  
  建立一个阻塞模式的tcp连接到一个没有监听的服务端口（肯定连不上，然后等待超时），然后将这个socket描述符，交由epoll管理。注册的epoll事件为：
  
  + event = EPOLLIN | EPOLLOUT | EPOLLRDHUP | EPOLLERR | EPOLLET | EPOLLPRI | EPOLLHUP

  结果：当tcp连接超时的时候，触发的事件有EPOLLIN 、 EPOLLOUT 、EPOLLRDHUP 、 EPOLLERR、EPOLLHUP，也就是只有紧急数据的事件没有发生。

## 二、调用read()，返回0时，继续write()

建立一个阻塞模式的tcp连接到有监听的服务器端口上，然后将这个socket描述符，交由epoll管理。注册的epoll事件为:

  + event = EPOLLIN | EPOLLOUT | EPOLLRDHUP | EPOLLERR | EPOLLET | EPOLLPRI | EPOLLHUP

当该描述符可写时，写10字节的数据到服务端；当该描述符可读时，读10字节的数据；服务端读10字节的数据，然后休眠5秒，之后close连接。
实验结果，总结如下：

1. tcp三次握手一旦完成，该socket描述符的EPOLLOUT触发，即可写
2. 服务端休眠5秒后，关闭连接。触发的事件有EPOLLIN 、 EPOLLOUT 、EPOLLRDHUP 、 EPOLLERR、EPOLLHUP。此时read返回0，write仍然可写
3. 之后又触发了EPOLLIN 、 EPOLLOUT事件。此时read仍然返回0，write出错，错误为SIGPIPE。这次触发的原因是，在2中的write了一个closed的连接，由于非阻塞，造成write成功的假象，所以这儿epoll又接到了通知，弥补上一步的错误。

## 三、调用read，返回0，不再write

建立一个阻塞模式的tcp连接到有监听的服务器端口上，然后将这个socket描述符，交由epoll管理。注册的epoll事件为:

  + event = EPOLLIN | EPOLLOUT | EPOLLRDHUP | EPOLLERR | EPOLLET | EPOLLPRI | EPOLLHUP

当read返回0后，不再write数据到服务端；服务端读10字节的数据，然后休眠5秒，之后close连接。

实验结果：

1. tcp三次握手一旦完成，该socket描述符的EPOLLOUT触发，即可写
2. 触发EPOLLIN 、 EPOLLOUT 、EPOLLRDHUP 、 EPOLLERR、EPOLLHUP。此时read返回0。之后不再有事件触发

## 四、在ET模式下，只需注册EPOLLIN | EPOLLOUT就可以了，如果有错误发生，这两个事件也被能触发，然后判断错误类型就可以了


文档信息
--------------
* 版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
* 转载: [http://www.ahlinux.com/]
{% endhighlight %}


转载: [Epoll实验总结](http://changzhiwin.blog.163.com/blog/static/7509649620128635410866/)

[jekyll]:      http://jekyllrb.com
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-help]: https://github.com/jekyll/jekyll-help
